

# clear everything out of memory
rm(list=ls())  
getwd()
dir_path <-"C:/Users/elnaj/Desktop/MSBA Classes/classes-FAll 2020/IDS 564 media netwrk analysis/final project"
setwd(dir_path)
myData <- read.table('ca-GrQc.txt.gz')
str(myData)
library(igraph)
library(dplyr)

#create graph 

el <- myData
g_GRCN=graph.data.frame(el, directed = FALSE, vertices= NULL)


################################
#initial analysis
################################

# Edges result :28980
ecount(g_GRCN)
## Vertices result:5242
vcount(g_GRCN)


#Is it a simple graph? No!
## Check whether Self_loops exist, as do multiple edges
is.simple(g_GRCN)

# should we simplify it?? i think so??? it makes it so much smaller
g_GRCN_simpl<-simplify(g_GRCN, edge.attr.comb="sum")
summary(g_GRCN_simpl)

E(g_GRCN_simpl)$weight <-1     #assign 1 to the edge weights

num_weight<-E(g_GRCN_simpl)$weight 
length(num_weight)    
E(g_GRCN_simpl)$weight <-num_weight  # like this??


# check components 

is_connected(g_GRCN)
is_connected(g_GRCN, mode = "weak")
is_connected(g_GRCN, mode = "strong")
count_components(g_GRCN) #355 


# so it's undirected--
transitivity(g_GRCN)  #.6298
# Avg. path length and diameter
average.path.length(g_GRCN, directed=FALSE)  #6.0485

diameter(g_GRCN, directed = FALSE)  #17
# Summarize the graph structure
summary(g_GRCN)  #5242 x 28980 (14484 simplified)

table(sapply(maximal.cliques(g_GRCN), length))
# 1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   18   20   21   22   24   26 
# 1 1606 1394  594  182   52   28   13    9    4    1    4    2    1    1    1    2    1    1    1    1    1 
# 32   34   35   43   44 
# 1    1    1    2    1 

######## for some of these larger ones, let's look deeper and try to understand what's going on in those

largest_cliques(g_GRCN)   # these are the 42 vertices from the largest clique--plot these!!

# [1] 21012 22691 773   14807 3372  21847 2741  24955 6610  25758 11241 570   6179  45    21281 23293 15003 20635
# [19] 19423 18894 4164  7956  12365 17655 25346 1653  9785  21508 14540 12781 2212  19961 2952  6830  8879  11472
# [37] 12496 12851 15659 17692 20108 20562 22887 4513





############## triangles #########################
transitivity(g_GRCN, type="global") #ratio of triangles (direction disregarded) to connected triples.
#.62984
mean(transitivity(g_GRCN, type="local")) # what does this do-check
# triad types in this network #



# mean degree

mean(degree(g_GRCN))  #11.057

# degrees- what is most prevalent in the network?
max(degree.distribution(g_GRCN))  #.22835

dd <- degree.distribution(g_GRCN)
#filter the ones with zero
str(dd)


keep <- which(dd>0)
n<- dd[keep]

barplot(n, xlim= c(1,50), col="blue",
        xlab= "Number of connections", main="Frequency of degrees in network- removing zeroes")



constraints_SAP <- round(constraint(g_GRCN_simpl, nodes=V(g_GRCN_simpl)), digits=4) #this gives NA if i include it in the correlation matrix so it's out rn
# Degree centrality
degree_sap <- degree(g_GRCN_simpl)
# Node betweenness
betweens_SAP <- round(betweenness(g_GRCN_simpl, v=V(g_GRCN_simpl), directed = FALSE, nobigint =TRUE, normalized = FALSE))
# Edge betwenness
edgebetweens_SAP<-edge.betweenness(g_GRCN_simpl, e=E(g_GRCN_simpl), directed = FALSE)
# Local clustering coefficients
clustering_SAP <- transitivity(g_GRCN_simpl, type="local", vids=V(g_GRCN_simpl)) 

meas <- cbind(degree_sap, edgebetweens_SAP, betweens_SAP)
round(cor(meas), 3)

# below is original network
# degree_sap edgebetweens_SAP constraints_SAP betweens_SAP
# degree_sap           1.0000          -0.0052         -0.6336       0.5170
# edgebetweens_SAP    -0.0052           1.0000          0.0041      -0.0021
# constraints_SAP     -0.6336           0.0041          1.0000      -0.4336
# betweens_SAP         0.5170          -0.0021         -0.4336       1.0000

###########################   clusters    ##############################################

is.connected(g_GRCN_simpl, mode = "strong")

clust1s <- clusters(g_GRCN_simpl, mode = "strong")
table(clust1s$csize)  
# 1    2    3    4    5    6    7    8    9   10   12   14 4158 
# 1  177   98   30   17   12    8    6    2    1    1    1    1 
table(clust1s$no)  #355 total clusters
#table(clust1s$membership)

# different cluster sizes
#get the ones with 2,3, 9 and plot

cs <- which(clust1s$csize == 2)
cs2 <- el[cs, ]
cs <- which(clust1s$csize == 3)
cs3 <- el[cs, ]
cs <- which(clust1s$csize == 4)
cs4 <- el[cs, ]

cs2 <- rbind(cs2, cs3, cs4)

g_GRCN2=graph.data.frame(cs2, directed = FALSE, vertices= NULL)

#g_GRCN2<-simplify(g_GRCN2, edge.attr.comb="sum")  do we need to simplify?

l=layout_with_drl(g_GRCN2)
plot(g_GRCN2, main = "strong with clusters =2, 3, 4", layout=l) #see some bridges to look out for

# Closeness Centrality
get.adjacency(g_GRCN, sparse=FALSE)
close_SAP <- closeness(g_GRCN)
mean(close_SAP)  # not too good

# can we do k means clustering w this??
g <- g_GRCN2
M<-as_adjacency_matrix(g, sparse=FALSE)

results <- mst.knn(M)

#igraph::V(results$network)$label.cex <- seq(0.6,0.6,length.out=2)

plot(results$network, vertex.size=8, 
     vertex.color=igraph::clusters(results$network)$membership, 
     layout=igraph::layout.fruchterman.reingold(results$network, niter=10000),
     main=paste("MST-kNN \n Clustering solution \n Number of clusters=",results$cnumber,sep="" ))








cw <- walktrap.community(s1)
modularity(cw)
#c.w1 <- membership(cw)

# a decent plot of the overall network - simplified
V(g_GRCN_simpl)$size <- 3*(graph.strength(g_GRCN_simpl))^(1/3)  #optimal for viewing
V(g_GRCN_simpl)$color <- "lightblue"
#l <- layout_with_kk(g_GRCN)
#edge weight-prop
#edge weight-prop
num_weight<-E(g_GRCN_simpl)$weight 
E(g_GRCN_simpl)$weight <- num_weight
E(g_GRCN_simpl)$width <- (E(g_GRCN_simpl)$weight)
plot(g_GRCN_simpl, vertex.label = NA, layout=layout_with_mds(g_GRCN_simpl),
     main="Original Network-Simplified")


summary(num_weight)

# doing walktrap is better if it's with smaller groups



#consider a subset on cliques instead of clusters?
v<- count_max_cliques(g_GRCN_simpl)
v  #they are part of  the largest clique


g_GRCN

# just looking at the largest clique
s1<-induced_subgraph(g_GRCN_simpl, v= largest.cliques(g_GRCN_simpl)[[1]])
s1
l=layout_with_gem(s1)

V(s1)$size <- 3*(graph.strength(s1))^(1/3)  #optimal for viewing
V(s1)$color <- "lightblue"
#l <- layout_with_kk(g_GRCN)
#edge weight-prop
#edge weight-prop
num_weight<-E(s1)$weight 
E(s1)$weight <- num_weight
E(s1)$width <- (E(s1)$weight)
plot(s1, vertex.label = NA, layout=l,
     main="Largest Clique In Network-GEM layout")

#all the weights are the same...


# subgraph with only the largest clique
edge_density(g_GRCN_simpl)
mean(degree(s1))

g <- g_GRCN_simpl   #this looks bad consider only subgroups for this viz
M<-as_adjacency_matrix(g, sparse=FALSE)

results <- mst.knn(M)

#igraph::V(results$network)$label.cex <- seq(0.6,0.6,length.out=2)

plot(results$network, vertex.size=.8, 
     vertex.color=igraph::clusters(results$network)$membership, 
     layout=igraph::layout.fruchterman.reingold(results$network, niter=10000),
     main=paste("MST-kNN \n Clustering solution \n Number of clusters=",results$cnumber,sep="" ))



num_weight<-E(g_GRCN_simpl)$weight
h<-hub.score(g_GRCN_simpl, scale=FALSE, weights = num_weight)$vector 
head(sort(h, decreasing=TRUE))

# so now the plot of auth/hub of the network before we split it up by highest hub/auth scores
auth_score <-authority.score(g_GRCN_simpl, scale=FALSE, weights = num_weight)$vector
head(sort(auth_score, decreasing=TRUE))

#hub and authorities are same since the graph is undirected



